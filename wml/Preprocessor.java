/* Preprocessor.java */
/* Generated By:JavaCC: Do not edit this line. Preprocessor.java */
package wml;

import java.awt.Color;
import java.util.*;
import java.util.logging.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;

import static wml.ANSIFormatter.*;

public class Preprocessor implements PreprocessorConstants {
        private final Logger pL = Logger.getLogger("preprocessor.parse");
        private boolean showParseLogs = false;
        private boolean warnParseLogs = false;

        private Color tdColor = new Color(255, 221, 0);
        private Color macroNameColor = new Color(0, 255, 128);
        private Color lineNumColor = new Color(0, 153, 255);
        private Color filePathColor = new Color(128, 192, 255);
        private Color tagColor = Color.decode("#00CED1");

        private Path currentPath = Path.of(".");
        private PrintStream out;
        private HashMap<String, Definition> defines = new HashMap<>();

        public Preprocessor(Path filePath) throws IOException {
                this(Files.newInputStream(filePath));
                this.currentPath = filePath;
        }

        public static void main(String[] args) {
                ArgParser argParse = new ArgParser();
                argParse.parseArgs(args);

                for (Handler handler : Logger.getLogger("").getHandlers()) {
                        handler.setFormatter(new java.util.logging.Formatter() {
                                @Override
                                public String format(LogRecord r) {
                                        // Customize Message for separators between Level and Message
                                        Level l = r.getLevel();
                                        String lvlStr = "[" + l + "]";
                                        if (l == Level.WARNING) {
                                                lvlStr = colorify(lvlStr, Color.RED);
                                        } else if (l == Level.INFO) {
                                                lvlStr = colorify(lvlStr, Color.CYAN);
                                        }

                                        return lvlStr + " " + r.getMessage() + "\n";
                                }
                        });
                }

                try {
                        Preprocessor p = new Preprocessor(System.in);
                        if (argParse.inputPath != null) {
                                p = new Preprocessor(argParse.inputPath);
                        }

                        p.showParseLogs = argParse.showParseLogs;
                        p.warnParseLogs = argParse.warnParseLogs;
                        p.out = (argParse.out == null) ? System.out : argParse.out;
                        p.token_source.dataPath = argParse.dataPath;
                        p.token_source.userDataPath = argParse.userDataPath;
                        p.token_source.showLogs = argParse.showLogs;

                        if (argParse.inputPath != null) {
                                p.debugPrint("Parsing " + colorify(argParse.inputPath.toString(), p.filePathColor));
                        }

                        for (Path incpath : argParse.includes) {
                                p.subparse(incpath);
                        }

                        p.subparse(argParse.inputPath);
                } catch(Exception e) {
                        e.printStackTrace();
                }
        }

        /**
	 * Create a preprocessor subprocess, that inherits properties
	 * from this one.
	 */
        private Preprocessor child(Path inpath) throws IOException {
                Preprocessor pinc = new Preprocessor(inpath);
                pinc.showParseLogs = showParseLogs;
                pinc.warnParseLogs = warnParseLogs;
                pinc.out = (getOutput() == null) ? System.out : getOutput();
                pinc.token_source.dataPath = token_source.dataPath;
                pinc.token_source.userDataPath = token_source.userDataPath;
                pinc.token_source.showLogs = token_source.showLogs;
                return pinc;
        }

        /**
	 * Recursively parse the given Path p
	 * Note: JavaCC doesn't support lambdas or :: yet!
	 */
        private void subparse(Path p) throws IOException, ParseException {
                Path path = p;
                if (Files.isDirectory(path)) {
                        Path p2 = path.resolve("./_main.cfg");
                        if (!Files.exists(p2)) {
                                File[] files = path.toFile().listFiles();
                                try {
                                        if (files == null) return;
                                        for (File f : files) {
                                                if (!f.isDirectory() && !f.getName().endsWith(".cfg")) return;
                                                subparse(f.toPath());
                                        }
                                        return;
                                } catch (IOException e) {
                                        e.printStackTrace();
                                }
                        } else {
                                path = p2;
                        }
                }

                debugPrint("Including: " + colorify(path.toString(), filePathColor));
                Preprocessor pp = child(path);
                pp.parse();
                addDefines(pp.getDefines());
        }

        /**
	 * Handwritten macro exapansion method
	 */
        private final String expandMacroCall(Vector<String> possibleArgs) throws ParseException {
                Token name = null;
                Vector<String> args = new Vector<>();

                StringBuffer sb = new StringBuffer();
                sb.append(token.image);

                if (token.kind == LBR) {
                        token = getNextToken();
                        if (skipWhitespace()) {
                                sb.append(" ");
                        }

                        // macro name
                        if (token.kind == STRING) {
                                name = token;
                                sb.append(token.image);
                                token = getNextToken();
                        } else {
                                generateParseException();
                        }

                        // arguments to macro call
                        while (token.kind != RBR) {
                                if (skipWhitespace()) {
                                        sb.append(" ");
                                }

                                if (token.kind == LBR) {
                                        String macroOutput = expandMacroCall(possibleArgs);
                                        sb.append(macroOutput);
                                        args.add(macroOutput);
                                } else if (token.kind == EOF) {
                                        generateParseException();
                                } else {
                                        sb.append(token.image);
                                        if (token.kind == INBLK) {
                                                args.add(token.image.substring(1, token.image.length() - 1));
                                        } else {
                                                args.add(token.image);
                                        }
                                        token = getNextToken();
                                }
                        }

                        // the ending brace
                        sb.append("}");
                        token = getNextToken();

                        // parsed name + args successfully, attempt expansion
                        Definition def = defines.get(name.image);
                        if (def != null) {
                                debugPrint(
                                        "Trying to expand macro " + colorify(def.name(), macroNameColor)
                                        + " with values: " + colorify(args.toString(), macroNameColor));
                                try {
                                        return def.expand(args);
                                } catch (IllegalArgumentException e) {
                                        e.printStackTrace();
                                        return sb.toString();
                                }
                        } else if (possibleArgs.contains(name.image)) {
                                // FIXME: do nothing for now. may need checks later.
                                return sb.toString();
                        } else {
                                warningPrint(position(name) + " undefined macro " + name.image);
                                return sb.toString();
                        }
                }

                return sb.toString();
        }


        // skip whitespace tokens
        private final boolean skipWhitespace() {
                boolean skipped = false;
                while (token.kind == SPACE) {
                        skipped = true;
                        token = getNextToken();
                }
                return skipped;
        }

        public PrintStream getOutput() {
                return out;
        }

        public void setOutput(PrintStream out) {
                this.out = out;
        }

        public HashMap<String, Definition> getDefines() {
                return this.defines;
        }

        public void addDefines(HashMap<String, Definition> newDefines) {
                this.defines.putAll(newDefines);
        }

        public void debugPrint(String s) {
                if (showParseLogs) {
                        pL.info(s);
                }
        }

        public void warningPrint(String s) {
                if (showParseLogs || warnParseLogs) {
                        pL.warning(s);
                }
        }

        public String position(Token tok) {
                return position(tok.beginLine, tok.beginColumn);
        }

        public String position(int line, int col) {
                return colorify("(" + line + ":" + col + ")", lineNumColor);
        }

  final public void parse() throws ParseException {Token tok; String content, exp;
    label_1:
    while (true) {
      if (jj_2_1(3)) {
        define();
      } else if (jj_2_2(3)) {
        content = tag();
out.print(content);
      } else if (jj_2_3(3)) {
        exp = expand(new Vector<String>());
out.print(exp);
      } else if (jj_2_4(3)) {
        ifdef();
      } else if (jj_2_5(3)) {
        undef();
      } else if (jj_2_6(3)) {
        expandPath();
      } else if (jj_2_7(3)) {
        textdomain();
      } else if (jj_2_8(3)) {
        tok = jj_consume_token(SPACE);
out.print(tok.image);
      } else if (jj_2_9(3)) {
        tok = jj_consume_token(EOL);
out.print(tok.image);
      } else if (jj_2_10(3)) {
        jj_consume_token(0);
debugPrint(defines.size() + " defines found.");
                        out.close();
                        {if ("" != null) return;}
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_11(3)) {
        ;
      } else {
        break label_1;
      }
    }
}

  final public String tag() throws ParseException {Token tstart, tend, body;
        String macro, contents;
        StringBuilder sb = new StringBuilder();
    tstart = jj_consume_token(STAG);
sb.append(tstart.image);
    if (jj_2_12(3)) {
      jj_consume_token(EOL);
sb.append("\n");
    } else {
      ;
    }
// TODO can check tag mismatch here
                        while (token.kind != ETAG) {
                                // System.out.println("Token: " + token.image + " at " + position(token) + " kind: " + token.kind);
                                if (token.kind == LBR) {
                                        // nested macro call
                                        sb.append(expandMacroCall(new Vector<String>()));
                                } else if (getToken(1).kind == STAG) {
                                        // nested tag
                                        sb.append(tag());
                                } else {
                                        // anything else is just appended as string to result
                                        sb.append(token.image);
                                        token = getNextToken();
                                }
                        }

                        debugPrint("Tag found: " + colorify(tstart.image, tagColor));
                        sb.append(token.image);
{if ("" != null) return sb.toString();}
    throw new Error("Missing return statement in function");
}

  final public void textdomain() throws ParseException {Token tok;
    jj_consume_token(TEXTDOMAIN);
    jj_consume_token(SPACE);
    tok = jj_consume_token(STRING);
debugPrint("Textdomain " + colorify(tok.image, tdColor));
}

  final public void define() throws ParseException {Token name, body, arg;
        StringBuilder sb = new StringBuilder();
        Definition def;
        String macro;
        Vector<String> args = new Vector<>();
    jj_consume_token(DEFINE);
    jj_consume_token(SPACE);
    name = jj_consume_token(STRING);
    label_2:
    while (true) {
      if (jj_2_13(3)) {
        ;
      } else {
        break label_2;
      }
      jj_consume_token(SPACE);
      arg = jj_consume_token(STRING);
args.add(arg.toString());
    }
    if (jj_2_14(3)) {
      jj_consume_token(EOL);
    } else {
      ;
    }
while (token.kind != ENDDEF) {
                        if (token.kind == LBR) {
                                // nested macro call
                                sb.append(expandMacroCall(args));
                        } else {
                                // anything else is just appended as string to result
                                sb.append(token.image);
                                token = getNextToken();
                        }
                }

                def = new Definition(name.toString(), sb.toString(), args);
                debugPrint("defining macro " + colorify(def.name(), macroNameColor));
                defines.put(name.toString(), def);
}

  final public String expand(Vector<String> possibleArgs) throws ParseException {Token name, arg;
        Vector<String> args = new Vector<>();
        StringBuilder sb = new StringBuilder();
        String macro;
    jj_consume_token(LBR);
    label_3:
    while (true) {
      if (jj_2_15(3)) {
        ;
      } else {
        break label_3;
      }
      jj_consume_token(SPACE);
    }
    name = jj_consume_token(STRING);
sb.append("{" + name.image);
    label_4:
    while (true) {
      if (jj_2_16(3)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(SPACE);
      if (jj_2_20(3)) {
        macro = expand(new Vector<>());
sb.append(" " + macro); args.add(macro);
      } else if (jj_2_21(3)) {
        if (jj_2_17(3)) {
          arg = jj_consume_token(STRING);
        } else if (jj_2_18(3)) {
          arg = jj_consume_token(MARG);
        } else if (jj_2_19(3)) {
          arg = jj_consume_token(PATH);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
sb.append(" " + arg.image); args.add(arg.toString());
      } else if (jj_2_22(3)) {
        arg = jj_consume_token(INBLK);
sb.append(" " + arg.image);
                                args.add(arg.image.substring(1, arg.image.length()-1));
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_5:
    while (true) {
      if (jj_2_23(3)) {
        ;
      } else {
        break label_5;
      }
      jj_consume_token(SPACE);
    }
    jj_consume_token(RBR);
sb.append("}");
Definition def = defines.get(name.image);
                if (def != null) {
                        debugPrint("expanding macro " + def.name());
                        try {
                                {if ("" != null) return def.expand(args);}
                        } catch(IllegalArgumentException e) {
                                e.printStackTrace();
                                {if ("" != null) return sb.toString();}
                        }
                } else if (possibleArgs.contains(name.image)) {
                        // FIXME: do nothing for now. may need checks later why this is happening.
                        {if ("" != null) return sb.toString();}
                } else {
                        warningPrint(position(name) + " undefined macro " + name.image);
                        {if ("" != null) return sb.toString();}
                }
    throw new Error("Missing return statement in function");
}

  final public void expandPath() throws ParseException {Token tok;
        StringBuilder sb = new StringBuilder();
    jj_consume_token(LBR);
    tok = jj_consume_token(PATH);
    jj_consume_token(RBR);
Path p;
                if (tok.image.startsWith(".")) {
                        if (Files.isDirectory(currentPath)) {
                                p = currentPath.resolve(tok.image);
                        } else {
                                p = currentPath.getParent().resolve(tok.image);
                        }
                } else if (tok.image.startsWith("~")) {
                        // Supports both ~add-ons and ~/add-ons
                        String relpath = tok.image.substring(1);
                        if (relpath.startsWith("/")) {
                                relpath = relpath.substring(1);
                        }
                        p = token_source.userDataPath.resolve(relpath);
                } else {
                        p = token_source.dataPath.resolve(tok.image);
                }

                debugPrint("Trying to include: " + colorify(p.toString(), filePathColor));

                if (!Files.isDirectory(p) && !p.toString().endsWith(".cfg")) {if ("" != null) return;}

                if (Files.exists(p)) {
                        debugPrint("Including: " + colorify(p.toString(), filePathColor));
                        try {
                                subparse(p);
                        } catch(IOException ioe) {
                                debugPrint("Cannot parse " + tok.image);
                                ioe.printStackTrace();
                        }
                } else {
                        warningPrint(tok.image + " not found");
                }
}

  final public void ifdef() throws ParseException {Token name;
    jj_consume_token(IFDEF);
    jj_consume_token(SPACE);
    name = jj_consume_token(STRING);
    jj_consume_token(EOL);
if (defines.get(name.image) == null) {
                        debugPrint("ifdef: define " + name.image + " not found, skipping block");
                        while (token.kind != ENDIF) {
                                token = getNextToken();
                        }
                } else {
                        debugPrint("ifdef: define " + name.image + " found, parsing block");
                }
}

  final public void undef() throws ParseException {Token name;
    jj_consume_token(UNDEF);
    jj_consume_token(SPACE);
    name = jj_consume_token(STRING);
debugPrint("removing macro " + name.toString());
                defines.remove(name.image);
}

  private boolean jj_2_1(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_1()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_2()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_3()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_4()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_5()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_6()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_7()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_8()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_9()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_10()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_11()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_12()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_13()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_14()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_15()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_16()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_17()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_18()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_19()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_20()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_21()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_22()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla)
 {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return (!jj_3_23()); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_3_15()
 {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_12()
 {
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  private boolean jj_3R_define_409_9_6()
 {
    if (jj_scan_token(DEFINE)) return true;
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3_19()
 {
    if (jj_scan_token(PATH)) return true;
    return false;
  }

  private boolean jj_3R_undef_541_9_10()
 {
    if (jj_scan_token(UNDEF)) return true;
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_textdomain_397_9_12()
 {
    if (jj_scan_token(TEXTDOMAIN)) return true;
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3R_expand_442_9_8()
 {
    if (jj_scan_token(LBR)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_15()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(STRING)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_23()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3R_tag_344_9_7()
 {
    if (jj_scan_token(STAG)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_18()
 {
    if (jj_scan_token(MARG)) return true;
    return false;
  }

  private boolean jj_3R_expandPath_482_9_11()
 {
    if (jj_scan_token(LBR)) return true;
    if (jj_scan_token(PATH)) return true;
    if (jj_scan_token(RBR)) return true;
    return false;
  }

  private boolean jj_3_10()
 {
    if (jj_scan_token(0)) return true;
    return false;
  }

  private boolean jj_3_9()
 {
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  private boolean jj_3_8()
 {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3R_ifdef_524_9_9()
 {
    if (jj_scan_token(IFDEF)) return true;
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3_13()
 {
    if (jj_scan_token(SPACE)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3_7()
 {
    if (jj_3R_textdomain_397_9_12()) return true;
    return false;
  }

  private boolean jj_3_6()
 {
    if (jj_3R_expandPath_482_9_11()) return true;
    return false;
  }

  private boolean jj_3_5()
 {
    if (jj_3R_undef_541_9_10()) return true;
    return false;
  }

  private boolean jj_3_4()
 {
    if (jj_3R_ifdef_524_9_9()) return true;
    return false;
  }

  private boolean jj_3_22()
 {
    if (jj_scan_token(INBLK)) return true;
    return false;
  }

  private boolean jj_3_3()
 {
    if (jj_3R_expand_442_9_8()) return true;
    return false;
  }

  private boolean jj_3_17()
 {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  private boolean jj_3_21()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3_19()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_2()
 {
    if (jj_3R_tag_344_9_7()) return true;
    return false;
  }

  private boolean jj_3_14()
 {
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  private boolean jj_3_20()
 {
    if (jj_3R_expand_442_9_8()) return true;
    return false;
  }

  private boolean jj_3_1()
 {
    if (jj_3R_define_409_9_6()) return true;
    return false;
  }

  private boolean jj_3_11()
 {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_1()) {
    jj_scanpos = xsp;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3_6()) {
    jj_scanpos = xsp;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3_10()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_23()
 {
    if (jj_scan_token(SPACE)) return true;
    return false;
  }

  private boolean jj_3_16()
 {
    if (jj_scan_token(SPACE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3_22()) return true;
    }
    }
    return false;
  }

  /** Generated Token Manager. */
  public PreprocessorTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[0];
  static private int[] jj_la1_0;
  static {
	   jj_la1_init_0();
	}
	private static void jj_la1_init_0() {
	   jj_la1_0 = new int[] {};
	}
  final private JJCalls[] jj_2_rtns = new JJCalls[23];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Preprocessor(java.io.InputStream stream) {
	  this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Preprocessor(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source = new PreprocessorTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
	  ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
	 try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < 0; i++) jj_la1[i] = -1;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Preprocessor(java.io.Reader stream) {
	 jj_input_stream = new SimpleCharStream(stream, 1, 1);
	 token_source = new PreprocessorTokenManager(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
	if (jj_input_stream == null) {
	   jj_input_stream = new SimpleCharStream(stream, 1, 1);
	} else {
	   jj_input_stream.ReInit(stream, 1, 1);
	}
	if (token_source == null) {
 token_source = new PreprocessorTokenManager(jj_input_stream);
	}

	 token_source.ReInit(jj_input_stream);
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Preprocessor(PreprocessorTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(PreprocessorTokenManager tm) {
	 token_source = tm;
	 token = new Token();
	 jj_ntk = -1;
	 jj_gen = 0;
	 for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
	 Token oldToken;
	 if ((oldToken = token).next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 if (token.kind == kind) {
	   jj_gen++;
	   if (++jj_gc > 100) {
		 jj_gc = 0;
		 for (int i = 0; i < jj_2_rtns.length; i++) {
		   JJCalls c = jj_2_rtns[i];
		   while (c != null) {
			 if (c.gen < jj_gen) c.first = null;
			 c = c.next;
		   }
		 }
	   }
	   return token;
	 }
	 token = oldToken;
	 jj_kind = kind;
	 throw generateParseException();
  }

  @SuppressWarnings("serial")
  static private final class LookaheadSuccess extends java.lang.Error {
    @Override
    public Throwable fillInStackTrace() {
      return this;
    }
  }
  static private final LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
	 if (jj_scanpos == jj_lastpos) {
	   jj_la--;
	   if (jj_scanpos.next == null) {
		 jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
	   } else {
		 jj_lastpos = jj_scanpos = jj_scanpos.next;
	   }
	 } else {
	   jj_scanpos = jj_scanpos.next;
	 }
	 if (jj_rescan) {
	   int i = 0; Token tok = token;
	   while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
	   if (tok != null) jj_add_error_token(kind, i);
	 }
	 if (jj_scanpos.kind != kind) return true;
	 if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
	 return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
	 if (token.next != null) token = token.next;
	 else token = token.next = token_source.getNextToken();
	 jj_ntk = -1;
	 jj_gen++;
	 return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
	 Token t = token;
	 for (int i = 0; i < index; i++) {
	   if (t.next != null) t = t.next;
	   else t = t.next = token_source.getNextToken();
	 }
	 return t;
  }

  private int jj_ntk_f() {
	 if ((jj_nt=token.next) == null)
	   return (jj_ntk = (token.next=token_source.getNextToken()).kind);
	 else
	   return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
	 if (pos >= 100) {
		return;
	 }

	 if (pos == jj_endpos + 1) {
	   jj_lasttokens[jj_endpos++] = kind;
	 } else if (jj_endpos != 0) {
	   jj_expentry = new int[jj_endpos];

	   for (int i = 0; i < jj_endpos; i++) {
		 jj_expentry[i] = jj_lasttokens[i];
	   }

	   for (int[] oldentry : jj_expentries) {
		 if (oldentry.length == jj_expentry.length) {
		   boolean isMatched = true;

		   for (int i = 0; i < jj_expentry.length; i++) {
			 if (oldentry[i] != jj_expentry[i]) {
			   isMatched = false;
			   break;
			 }

		   }
		   if (isMatched) {
			 jj_expentries.add(jj_expentry);
			 break;
		   }
		 }
	   }

	   if (pos != 0) {
		 jj_lasttokens[(jj_endpos = pos) - 1] = kind;
	   }
	 }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
	 jj_expentries.clear();
	 boolean[] la1tokens = new boolean[27];
	 if (jj_kind >= 0) {
	   la1tokens[jj_kind] = true;
	   jj_kind = -1;
	 }
	 for (int i = 0; i < 0; i++) {
	   if (jj_la1[i] == jj_gen) {
		 for (int j = 0; j < 32; j++) {
		   if ((jj_la1_0[i] & (1<<j)) != 0) {
			 la1tokens[j] = true;
		   }
		 }
	   }
	 }
	 for (int i = 0; i < 27; i++) {
	   if (la1tokens[i]) {
		 jj_expentry = new int[1];
		 jj_expentry[0] = i;
		 jj_expentries.add(jj_expentry);
	   }
	 }
	 jj_endpos = 0;
	 jj_rescan_token();
	 jj_add_error_token(0, 0);
	 int[][] exptokseq = new int[jj_expentries.size()][];
	 for (int i = 0; i < jj_expentries.size(); i++) {
	   exptokseq[i] = jj_expentries.get(i);
	 }
	 return new ParseException(token, exptokseq, tokenImage);
  }

  private boolean trace_enabled;

/** Trace enabled. */
  final public boolean trace_enabled() {
	 return trace_enabled;
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
	 jj_rescan = true;
	 for (int i = 0; i < 23; i++) {
	   try {
		 JJCalls p = jj_2_rtns[i];

		 do {
		   if (p.gen > jj_gen) {
			 jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
			 switch (i) {
			   case 0: jj_3_1(); break;
			   case 1: jj_3_2(); break;
			   case 2: jj_3_3(); break;
			   case 3: jj_3_4(); break;
			   case 4: jj_3_5(); break;
			   case 5: jj_3_6(); break;
			   case 6: jj_3_7(); break;
			   case 7: jj_3_8(); break;
			   case 8: jj_3_9(); break;
			   case 9: jj_3_10(); break;
			   case 10: jj_3_11(); break;
			   case 11: jj_3_12(); break;
			   case 12: jj_3_13(); break;
			   case 13: jj_3_14(); break;
			   case 14: jj_3_15(); break;
			   case 15: jj_3_16(); break;
			   case 16: jj_3_17(); break;
			   case 17: jj_3_18(); break;
			   case 18: jj_3_19(); break;
			   case 19: jj_3_20(); break;
			   case 20: jj_3_21(); break;
			   case 21: jj_3_22(); break;
			   case 22: jj_3_23(); break;
			 }
		   }
		   p = p.next;
		 } while (p != null);

		 } catch(LookaheadSuccess ls) { }
	 }
	 jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
	 JJCalls p = jj_2_rtns[index];
	 while (p.gen > jj_gen) {
	   if (p.next == null) { p = p.next = new JJCalls(); break; }
	   p = p.next;
	 }

	 p.gen = jj_gen + xla - jj_la; 
	 p.first = token;
	 p.arg = xla;
  }

  static final class JJCalls {
	 int gen;
	 Token first;
	 int arg;
	 JJCalls next;
  }

}
