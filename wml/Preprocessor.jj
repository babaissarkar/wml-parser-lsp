options
{
	LOOKAHEAD=3;
	STATIC=false;
	// Enable these to print verbose javacc logs
	DEBUG_PARSER = false;
	DEBUG_LOOKAHEAD = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Preprocessor)
package wml;

import java.awt.Color;
import java.util.*;
import java.util.logging.*;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;

import static wml.ANSIFormatter.*;

public class Preprocessor {
	private final Logger pL = Logger.getLogger("preprocessor.parse");
	private boolean showParseLogs = false;
	private boolean warnParseLogs = false;

	private Color tdColor = new Color(255, 221, 0);
	private Color macroNameColor = new Color(0, 255, 128);
	private Color lineNumColor = new Color(0, 153, 255);
	private Color filePathColor = new Color(128, 192, 255);
	private Color tagColor = Color.decode("#00CED1");

	private PrintStream out;
	private HashMap<String, Definition> defines = new HashMap<>();

	public static void main(String[] args) {
		ArgParser argParse = new ArgParser();
		argParse.parseArgs(args);

		for (Handler handler : Logger.getLogger("").getHandlers()) {
			handler.setFormatter(new java.util.logging.Formatter() {
				@Override
				public String format(LogRecord r) {
					// Customize Message for separators between Level and Message
					Level l = r.getLevel();
					String lvlStr = "[" + l + "]";
					if (l == Level.WARNING) {
						lvlStr = colorify(lvlStr, Color.RED);
					} else if (l == Level.INFO) {
						lvlStr = colorify(lvlStr, Color.CYAN);
					}

					return lvlStr + " " + r.getMessage() + "\n";
				}
			});
		}

		try {
			Preprocessor p = new Preprocessor(System.in);
			if (argParse.inputPath != null) {
				p = new Preprocessor(Files.newInputStream(argParse.inputPath));
			}

			p.showParseLogs = argParse.showParseLogs;
			p.warnParseLogs = argParse.warnParseLogs;
			p.out = (argParse.out == null) ? System.out : argParse.out;
			p.token_source.dataPath = argParse.dataPath;
			p.token_source.userDataPath = argParse.userDataPath;
			p.token_source.showLogs = argParse.showLogs;

			if (argParse.inputPath != null) {
				p.debugPrint("Parsing " + colorify(argParse.inputPath.toString(), p.filePathColor));
			}

			for (Path incpath : argParse.includes) {
				p.subparse(incpath);
			}

			p.subparse(argParse.inputPath);
		} catch(Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * Create a preprocessor subprocess, that inherits properties
	 * from this one.
	 */
	private Preprocessor child(InputStream in) {
		Preprocessor pinc = new Preprocessor(in);
		pinc.showParseLogs = showParseLogs;
		pinc.warnParseLogs = warnParseLogs;
		pinc.out = (getOutput() == null) ? System.out : getOutput();
		pinc.token_source.dataPath = token_source.dataPath;
		pinc.token_source.userDataPath = token_source.userDataPath;
		pinc.token_source.showLogs = token_source.showLogs;
		return pinc;
	}

	/**
	 * Recursively parse the given Path p
	 * Note: JavaCC doesn't support lambdas or :: yet!
	 */
	private void subparse(Path p) throws IOException, ParseException {
		Path path = p;
		if (Files.isDirectory(path)) {
			Path p2 = path.resolve("./_main.cfg");
			if (!Files.exists(p2)) {
				File[] files = path.toFile().listFiles();
				try {
					if (files == null) return;
					for (File f : files) {
						if (!f.isDirectory() && !f.getName().endsWith(".cfg")) return;
						subparse(f.toPath());
					}
					return;
				} catch (IOException e) {
					e.printStackTrace();
				}
			} else {
				path = p2;
			}
		}

		debugPrint("Including: " + colorify(path.toString(), filePathColor));
		Preprocessor p2 = child(Files.newInputStream(path));
		p2.parse();
		addDefines(p2.getDefines());
	}

	/**
	 * Handwritten macro exapansion method
	 */
	// public final String expandMacroCall(Vector<String> possibleArgs) throws ParseException {
	// 	Token name = null;
	// 	Vector<String> args = new Vector<>();

	// 	StringBuffer sb = new StringBuffer();
	// 	sb.append(token.image);
	// 	if (token.kind == LBR) {
	// 		skipWhitespace();
	// 		sb.append(" ");

	// 		// macro name
	// 		if (token.kind == STRING) {
	// 			name = token;
	// 			sb.append(token.image);
	// 		} else {
	// 			// there must be a macro name
	// 			generateParseException();
	// 		}

	// 		// arguments to macro call
	// 		while (token.kind != RBR) {
	// 			skipWhitespace();
	// 			sb.append(" ");

	// 			if (token.kind == LBR) {
	// 				// macro arg is a nested macro call
	// 				sb.append(expandMacroCall(new Vector<>()));
	// 			} else if (token.kind == EOF) {
	// 				generateParseException();
	// 			} else {
	// 				sb.append(token.image);
	// 				if (token.kind == INBLK) {
	// 					args.add(token.image.substring(1, token.image.length()-1));
	// 				} else {
	// 					args.add(token.image);
	// 				}
	// 				token = getNextToken();
	// 			}
	// 		}

	// 		// the ending brace
	// 		sb.append("}");
	// 		token = getNextToken();

	// 		// parsed name all args successfully, attempt expansion
	// 		Definition def = defines.get(name.image);
	// 		if (def != null) {
	// 			debugPrint("expanding macro " + name.image);
	// 			try {
	// 				return def.expand(args);
	// 			} catch(IllegalArgumentException e) {
	// 				e.printStackTrace();
	// 				return sb.toString();
	// 			}
	// 		} else if (possibleArgs.contains(name.image)) {
	// 			// FIXME: do nothing for now. may need checks later why this is happening.
	// 			return sb.toString();
	// 		} else {
	// 			warningPrint(position(name) + " undefined macro " + name.image);
	// 			return sb.toString();
	// 		}
	// 	}

	// 	return sb.toString();
	// }

	public final String expandMacroCall(Vector<String> possibleArgs) throws ParseException {
		Token name = null;
		Vector<String> args = new Vector<>();

		StringBuffer sb = new StringBuffer();
		sb.append(token.image);
		System.out.println("[expandMacroCall] Starting with token: " + token.image + " (kind=" + token.kind + ")");

		if (token.kind == LBR) {
			System.out.println("[expandMacroCall] Found LBR (begin macro call)");

			token = getNextToken();
			if (skipWhitespace()) {
				sb.append(" ");
			}

			// macro name
			if (token.kind == STRING) {
				name = token;
				sb.append(token.image);
				token = getNextToken();
				System.out.println("[expandMacroCall] Macro name: " + name.image);
			} else {
				System.out.println("[expandMacroCall] ERROR: Expected macro name (STRING), got kind=" + token.kind);
				generateParseException();
			}

			// arguments to macro call
			while (token.kind != RBR) {
				if (skipWhitespace()) {
					sb.append(" ");
				}

				if (token.kind == LBR) {
					System.out.println("[expandMacroCall] Found nested macro call");
					sb.append(expandMacroCall(new Vector<>()));
				} else if (token.kind == EOF) {
					System.out.println("[expandMacroCall] ERROR: Unexpected EOF inside macro call");
					generateParseException();
				} else {
					System.out.println("[expandMacroCall] Found argument token: " + token.image + " (kind=" + token.kind + ")");
					sb.append(token.image);
					if (token.kind == INBLK) {
						args.add(token.image.substring(1, token.image.length() - 1));
						System.out.println("[expandMacroCall] Added INBLK arg: " + args.lastElement());
					} else {
						args.add(token.image);
						System.out.println("[expandMacroCall] Added arg: " + args.lastElement());
					}
					token = getNextToken();
					System.out.println("[expandMacroCall] Next token: " + token.image + " (kind=" + token.kind + ")");
				}
			}

			// the ending brace
			System.out.println("[expandMacroCall] Found RBR (end macro call)");
			sb.append("}");
			token = getNextToken();
			System.out.println("[expandMacroCall] Next token after RBR: " + token.image + " (kind=" + token.kind + ")");

			// parsed name + args successfully, attempt expansion
			Definition def = defines.get(name.image);
			if (def != null) {
				System.out.println("[expandMacroCall] Expanding macro: " + name.image + " with args=" + args);
				try {
					return def.expand(args);
				} catch (IllegalArgumentException e) {
					System.out.println("[expandMacroCall] ERROR expanding macro: " + e.getMessage());
					e.printStackTrace();
					return sb.toString();
				}
			} else if (possibleArgs.contains(name.image)) {
				System.out.println("[expandMacroCall] Macro name " + name.image + " found in possibleArgs, returning raw");
				return sb.toString();
			} else {
				System.out.println("[expandMacroCall] WARNING: Undefined macro " + name.image);
				warningPrint(position(name) + " undefined macro " + name.image);
				return sb.toString();
			}
		}

		System.out.println("[expandMacroCall] Not a macro call (no LBR), returning raw: " + sb.toString());
		return sb.toString();
	}


	// skip whitespace tokens
	private final boolean skipWhitespace() {
		boolean skipped = false;
		while (token.kind == SPACE) {
			skipped = true;
			token = getNextToken();
		}
		return skipped;
	}

	public PrintStream getOutput() {
		return out;
	}

	public void setOutput(PrintStream out) {
		this.out = out;
	}

	public HashMap<String, Definition> getDefines() {
		return this.defines;
	}

	public void addDefines(HashMap<String, Definition> newDefines) {
		this.defines.putAll(newDefines);
	}

	public void debugPrint(String s) {
		if (showParseLogs) {
			pL.info(s);
		}
	}

	public void warningPrint(String s) {
		if (showParseLogs || warnParseLogs) {
			pL.warning(s);
		}
	}

	public String position(Token tok) {
		return position(tok.beginLine, tok.beginColumn);
	}

	public String position(int line, int col) {
		return colorify("(" + line + ":" + col + ")", lineNumColor);
	}
}

PARSER_END(Preprocessor)

TOKEN_MGR_DECLS : {
	private final Logger tL = Logger.getLogger("preprocessor.token");

	public boolean showLogs = false;
	public Path dataPath;
	public Path userDataPath;

	public void debugPrint(String s) {
		if (showLogs) {
			tL.info(s);
		}
	}
}

TOKEN : {
	< DEFINE : "#define" >	{ debugPrint("DEFINE"); }
|	< ENDDEF : "#enddef" >	{ debugPrint("ENDDEF"); }
|	< IFDEF  : "#ifdef" >	{ debugPrint("IFDEF"); }
|	< ENDIF  : "#endif" >	{ debugPrint("ENDIF"); }
|	< UNDEF  : "#undef" >	{ debugPrint("UNDEF"); }
|	< TEXTDOMAIN : "#textdomain" > { debugPrint("TEXTDOMAIN"); }
|	< LBR    : "{" >		{ debugPrint("Left Brace"); }
|	< RBR    : "}" >		{ debugPrint("Right Brace"); }
|	< LSB    : "[" >		{ debugPrint("Left Sq Bkt"); }
|	< RSB    : "]" >		{ debugPrint("Right Sq Bkt"); }
|	< LPAR   : "(" >		{ debugPrint("Left Par"); }
|	< RPAR   : ")" >		{ debugPrint("Right Par"); }
|	< EQL    : "=" >		{ debugPrint("Equals"); }
|	< SLASH  : "/" >		{ debugPrint("Slash"); }
|	< SPACE  : " "|"\t" >	{ debugPrint("Space"); }
|	< INBLK  : <LPAR> (~[")"])+ <RPAR> >
|	< STAG   : <LSB> (["a"-"z"]|<DIGIT>|"_")+ <RSB> > { debugPrint("Start tag"); }
|	< ETAG   : <LSB> <SLASH> (["a"-"z"]|<DIGIT>|"_")+ <RSB> > { debugPrint("End tag"); }
|	< PATH   : (<STRING>) (<SLASH>) (<STRING>|<SLASH>)+ >	{ debugPrint("Path"); }
|	< STRING : (<LETTER>|<DIGIT>)+ >						{ debugPrint("STRING"); }
|	< MARG   : (<LETTER>|<DIGIT>|<LSB>|<RSB>|<SLASH>)+ >	{ debugPrint("STRING"); } // yes, macro arguments can have newline!
|	< NUMBER : (<DIGIT>)+ ("." (<DIGIT>)+)? >				{ debugPrint("NUMBER"); }
|	< LETTER :
		["A"-"Z"]|["a"-"z"]|<EQL>|"?"|"!"|":"|";"|"."|","|"‘"|"’"|"%"
		|"_"|"-"|"'"|"+"|">"|"<"|<LPAR>|<RPAR>|"~"|"*"|"^"|"\""
		|"“"|"”"|"―"|"—"|"|"|"\\"|"$"|"@"
	>
	{ debugPrint("LETTER"); }
|	< DIGIT  : ["0"-"9"] >					{ debugPrint("DIGIT"); }
|	< EOL    : "\n"|"\r"|"\r\n" >			{ debugPrint("EOL"); }
}

SKIP : { < ("# "|"#\t"|"#!"|"##"|"#\n"|"#\r") (~["\n","\r"])* ("\n"|"\r"|"\r\n") > }

void parse() :
{
	Token tok; String content, exp;
}
{
	(
		  define()
		| content=tag() { out.print(content); }
		| exp=expand(new Vector<String>()) { out.print(exp); }
		| ifdef()
		| undef()
		| expandPath()
		| textdomain()
//		| <COMMENT>
		| tok=<SPACE>   { out.print(tok.image); }
		| tok=<EOL>     { out.print(tok.image); }
		| <EOF> {
			debugPrint(defines.size() + " defines found.");
			out.close();
			return;
		}
	)+
}

String tag() :
{
	Token tstart, tend, body;
	String macro, contents;
	StringBuilder sb = new StringBuilder();
}
{
	(
		(tstart=<STAG>) { sb.append(tstart.image); }
		(
			(<EOL>) { sb.append("\n"); }
		)?
		(
			(
				macro=expand(new Vector<String>())
			) { sb.append(macro); }
			|
			(
				  body=<STRING>
				| body=<MARG>
				| body=<RBR>
				| body=<LSB>
				| body=<RSB>
				| body=<SPACE>
				| body=<EOL>
				| body=<PATH>
				| body=<INBLK>
			) { sb.append(body.toString()); }
			|
			( contents=tag() { sb.append(contents); } )
		)+
		(tend=<ETAG>) {
			// TODO can check tag mismatch here
			debugPrint("Tag found: " + colorify(tstart.image, tagColor));
			sb.append(tend.image);
		}
	) { return sb.toString(); }
}

void textdomain() :
{
	Token tok;
}
{
	<TEXTDOMAIN> <SPACE> (tok=<STRING>) { debugPrint("Textdomain " + colorify(tok.image, tdColor)); }
}

void define() :
{
	Token name, body, arg;
	StringBuilder sb = new StringBuilder();
	Definition def;
	String macro;
	Vector<String> args = new Vector<>();
}
{
	(
		<DEFINE> <SPACE>
		(name=<STRING>)
		(
			<SPACE> (arg=<STRING>) { args.add(arg.toString()); }
		)*
		(<EOL>)?
		// (
		// 	(
		// 		macro=expandMacroCall(args)
		// 	) { sb.append(macro); }
		// 	|
		// 	(
		// 		  body=<STRING>
		// 		| body=<MARG>
		// 		| body=<LBR>
		// 		| body=<RBR>
		// 		| body=<LSB>
		// 		| body=<RSB>
		// 		| body=<SPACE>
		// 		| body=<EOL>
		// 		| body=<PATH>
		// 		| body=<STAG>
		// 		| body=<ETAG>
		// 	) { sb.append(body.toString()); }
		// )+
		// <ENDDEF>
	) {
		System.out.println("Define body");
		System.out.println("tok:" + token.image);
		while (token.kind != ENDDEF) {
			System.out.println("Consuming token: (" + token.image + ")");
			if (token.kind == LBR) {
				sb.append(expandMacroCall(args));
			} else {
				sb.append(token.image);
				token = getNextToken();
			}
		}

		def = new Definition(name.toString(), sb.toString(), args);
		debugPrint("defining macro " + colorify(name.toString(), macroNameColor));
		defines.put(name.toString(), def);
	}
}

String expand(Vector<String> possibleArgs) :
{
	Token name, arg;
	Vector<String> args = new Vector<>();
	StringBuilder sb = new StringBuilder();
	String macro;
}
{
	(
		(<LBR>) (<SPACE>)* (name=<STRING>) { sb.append("{" + name.image); }
		(
			<SPACE> (
				macro=expand(new Vector<>()) { sb.append(" " + macro); args.add(macro); }
			|	(arg=<STRING>|arg=<MARG>|arg=<PATH>) { sb.append(" " + arg.image); args.add(arg.toString()); }
			|	(arg=<INBLK>) {
				sb.append(" " + arg.image);
				args.add(arg.image.substring(1, arg.image.length()-1));
			} // fix for parens
			)
		)*
		(<SPACE>)*
		(<RBR>) { sb.append("}"); }
	) {
		Definition def = defines.get(name.image);
		if (def != null) {
			debugPrint("expanding macro " + name.image);
			try {
				return def.expand(args);
			} catch(IllegalArgumentException e) {
				e.printStackTrace();
				return sb.toString();
			}
		} else if (possibleArgs.contains(name.image)) {
			// FIXME: do nothing for now. may need checks later why this is happening.
			return sb.toString();
		} else {
			warningPrint(position(name) + " undefined macro " + name.image);
			return sb.toString();
		}
	}
}

void expandPath() :
{
	Token tok;
	StringBuilder sb = new StringBuilder();
}
{
	(<LBR> (tok=<PATH>) <RBR>) {
		Path p;
		if (tok.image.startsWith(".")) {
			p = Path.of(tok.image);
		} else if (tok.image.startsWith("~")) {
			// Supports both ~add-ons and ~/add-ons
			String relpath = tok.image.substring(1);
			if (relpath.startsWith("/")) {
				relpath = relpath.substring(1);
			}
			p = token_source.userDataPath.resolve(relpath);
		} else {
			p = token_source.dataPath.resolve(tok.image);
		}

		debugPrint("Trying to include: " + colorify(p.toString(), filePathColor));

		if (!Files.isDirectory(p) && !p.toString().endsWith(".cfg")) return;

		if (Files.exists(p)) {
			debugPrint("Including: " + colorify(p.toString(), filePathColor));
			try {
				subparse(p);
			} catch(IOException ioe) {
				debugPrint("Cannot parse " + tok.image);
				ioe.printStackTrace();
			}
		} else {
			warningPrint(tok.image + " not found");
		}
	}
}

void ifdef() :
{
	Token name;
}
{
	(<IFDEF> <SPACE> (name=<STRING>) <EOL>) {
		if (defines.get(name.image) == null) {
			debugPrint("ifdef: define " + name.image + " not found, skipping block");
			while (token.kind != ENDIF) {
				token = getNextToken();
			}
		} else {
			debugPrint("ifdef: define " + name.image + " found, parsing block");
		}
	}
}

void undef() :
{
	Token name;
}
{
	<UNDEF> <SPACE> (name=<STRING>) {
		debugPrint("removing macro " + name.toString());
		defines.remove(name.image);
	}

}


