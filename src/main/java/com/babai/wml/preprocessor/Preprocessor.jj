options
{
	LOOKAHEAD=3;
	STATIC=false;
	// Enable these to print verbose javacc logs
	DEBUG_PARSER = false;
	DEBUG_LOOKAHEAD = false;
	DEBUG_TOKEN_MANAGER = false;
}

PARSER_BEGIN(Preprocessor)
package com.babai.wml.preprocessor;

import java.util.*;
import java.util.logging.Logger;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;

import com.babai.wml.core.*;
import com.babai.wml.utils.FS;
import com.babai.wml.utils.Table;

import static com.babai.wml.utils.Colors.*;
import static com.babai.wml.utils.ANSIFormatter.*;

public class Preprocessor {
	private final Logger pL = Logger.getLogger("preprocessor.parse");
	private boolean showParseLogs = false;
	private boolean warnParseLogs = false;
	private boolean disableErrors = true;
	private static Vector<Path> bpaths = new Vector<>();

	private Path currentPath = Path.of(".");
	private PrintStream out;
	Table defines = Table.ofWithIndices(
			new Class<?>[]{Integer.class, String.class, String.class, Definition.class},
			new String[]{"Line", "URI", "Name", "Definition"},
			2  // index by Name column
	);

	// TODO don't expose this, and just use subparse
	public Preprocessor(Path filePath) throws IOException {
		this(Files.newInputStream(filePath));
		this.currentPath = filePath;
	}

	/**
	 * Create a preprocessor subprocess, that inherits properties
	 * from this one.
	 */
	private Preprocessor child(Path inpath) throws IOException {
		var pinc = new Preprocessor(inpath);
		pinc.showParseLogs = showParseLogs;
		pinc.warnParseLogs = warnParseLogs;
		pinc.out = getOutput();
		pinc.token_source.dataPath = token_source.dataPath;
		pinc.token_source.userDataPath = token_source.userDataPath;
		pinc.token_source.showLogs = token_source.showLogs;
		pinc.setDefinesMap(this.defines);
		return pinc;
	}

	/**
	 * Recursively parse the given Path p
	 * Note: JavaCC doesn't support lambdas or :: yet!
	 */
	public void subparse(Path p) throws IOException {
		Path path = p;
		if (Files.isDirectory(path)) {
			Path p2 = path.resolve("./_main.cfg");
			if (!Files.exists(p2)) {
				List<File> files = Arrays.asList(path.toFile().listFiles());
				Collections.sort(files);
				try {
					if (files == null) return;
					for (File f : files) {
						if (!f.isDirectory() && !f.getName().endsWith(".cfg")) return;
						subparse(f.toPath());
					}
					return;
				} catch (IOException e) {
					errorPrint("Cannot find " + path + ", skipping.");
				}
			} else {
				path = p2;
			}
		}
		
		debugPrint("Including: " + colorify(path.toString(), filePathColor));
		try {
			Preprocessor pp = child(path);
			pp.parse();
			setDefinesMap(pp.getDefines());
		} catch (ParseException pe) {
			errorPrint("Error parsing " + path + ", skipping.");
		}
	}

	// skip whitespace tokens
	private final boolean skipWhitespace() {
		boolean skipped = false;
		while (token.kind == SPACE) {
			skipped = true;
			token = getNextToken();
		}
		return skipped;
	}

	private final void handleDirectiveOrComment() throws ParseException {
		Token t = getToken(1);
		switch (t.kind) {
		case DEFINE:
			define();
			break;
		case IFDEF:
			ifdef();
			break;
		case UNDEF:
			undef();
			break;
		case TEXTDOMAIN:
			textdomain();
			break;
		default:
			while (token.kind != EOL) {
				token = getNextToken();
			}
			break;
		}
	}
	
	private final String[] parseBodyUntil(int endTokenType, Vector<String> args) throws ParseException {
		if (getToken(1).kind != LBR) {
			// usually it starts with EOL, skip unless
			// EOL is followed by LBR, in which case the
			// first case while block below with deal with it.
			token = getNextToken();
		}
		var sb = new StringBuffer();
		var docb = new StringBuffer();
		
		// Macro documentation comments vars
		boolean consumeComments = true;
		boolean inComment = false;
		
		while (token.kind != endTokenType) {
			if (getToken(1).kind == LBR && !inComment) {
				// nested macro call
				sb.append(token.image);
				sb.append(expandAll(args));
			} else if (token.kind == HASH) {
				// handleDirectiveOrComment(); // FIXME faulty
				if (consumeComments) {
					inComment = true;
				}
			} else if (token.kind == EOL) {
				if (inComment) {
					docb.append("\n\n");
					inComment = false;
				}
			} else {
				// anything else is just appended as string to result
				if (inComment) {
					docb.append(token.image);
				} else {
					if (token.kind != SPACE) {
						consumeComments = false;
					}
					sb.append(token.image);
				}
			}
			token = getNextToken();
		}
		String[] outputs = new String[2];
		outputs[0] = sb.toString();
		outputs[1] = docb.toString();
		return outputs;
	}

	public PrintStream getOutput() {
		return out;
	}

	public void setOutput(PrintStream out) {
		this.out = out;
	}

	public Table getDefines() {
		return this.defines;
	}
	
	public Vector<Path> getBinaryPaths() {
		return Preprocessor.bpaths;
	}
	
	public void setDefinesMap(Table defines) {
		this.defines = defines;
	}
	
	public void showParseLogs(boolean showParseLogs) {
		this.showParseLogs = showParseLogs;
	}
	
	public void showWarnLogs(boolean showWarnLogs) {
		this.warnParseLogs = showWarnLogs;
	}

	public void debugPrint(String s) {
		if (showParseLogs) {
			pL.info(s);
		}
	}

	public void warningPrint(String s) {
		if (showParseLogs || warnParseLogs) {
			pL.warning(s);
		}
	}
	
	public void errorPrint(String s) {
		// temporary, to test lsp
		if (!disableErrors) {
			pL.severe(s);
		}
	}

	public String position(Token tok) {
		return position(tok.beginLine, tok.beginColumn);
	}

	public String position(int line, int col) {
		return colorify("(" + line + ":" + col + ")", lineNumColor);
	}
}

PARSER_END(Preprocessor)

TOKEN_MGR_DECLS : {
	private final Logger tL = Logger.getLogger("preprocessor.token");

	public boolean showLogs = false;
	public Path dataPath;
	public Path userDataPath;

	public void debugPrint(String s) {
		if (showLogs) {
			tL.info(s);
		}
	}
}

// Angle bracket handling
<DEFAULT> TOKEN : {
	< ANGLE_OPEN: "<<" > { SwitchTo(ANGLE); }
}

<ANGLE> MORE : { < ~[] > }   // gobbles characters, appends to token ANGLE_OPEN

<ANGLE> TOKEN : {
	< ANGLE_CLOSE: ">>" > {
		matchedToken.kind = STRING;
		SwitchTo(DEFAULT);
	}
}

// Default args
TOKEN : {
	< ARG    : "#arg"   >
|	< ENDARG : "#endarg" >
}

// Other tokens
TOKEN : {
	< DEFINE : "define" >	{ debugPrint("DEFINE"); }
|	< ENDDEF : "enddef" >	{ debugPrint("ENDDEF"); }
|	< IFDEF  : "ifdef" >	{ debugPrint("IFDEF"); }
|	< ENDIF  : "endif" >	{ debugPrint("ENDIF"); }
|	< UNDEF  : "undef" >	{ debugPrint("UNDEF"); }
|	< TEXTDOMAIN : "textdomain" > { debugPrint("TEXTDOMAIN"); }

|	< LBR    : "{" >		{ debugPrint("Left Brace"); }
|	< RBR    : "}" >		{ debugPrint("Right Brace"); }
|	< LSB    : "[" >		{ debugPrint("Left Sq Bkt"); }
|	< RSB    : "]" >		{ debugPrint("Right Sq Bkt"); }
|	< LPAR   : "(" >		{ debugPrint("Left Par"); }
|	< RPAR   : ")" >		{ debugPrint("Right Par"); }
|	< LANGLE : "<" >		{ debugPrint("Left Angle"); }
|	< RANGLE : ">" >		{ debugPrint("Right Angle"); }
|	< EQL    : "=" >		{ debugPrint("Equals"); }
|	< SLASH  : "/" >		{ debugPrint("Slash"); }
|	< HASH   : "#" >		{ debugPrint("Hash"); }
|	< SPACE  : (" "|"\t")+ >	{ debugPrint("Space"); }

|	< QUOTED_STRING: "\"" (~["\""])* "\"" > { debugPrint("quoted string"); }
|	< INBLK  : <LPAR> (~[")"])+ <RPAR> >

|	< STAG   : <LSB> (["a"-"z"]|<DIGIT>|"_")+ <RSB> > { debugPrint("Start tag"); }
|	< ETAG   : <LSB> <SLASH> (["a"-"z"]|<DIGIT>|"_")+ <RSB> > { debugPrint("End tag"); }

|	< PATH   : (<STRING>) (<SLASH>) (<STRING>|<SLASH>)+ >	{ debugPrint("Path"); }
|	< STRING : (<LETTER>|<DIGIT>)+ >						{ debugPrint("STRING"); }
// please, don't go paranoid at this menagerie of characters!
// turns out Wesnoth had been through bizzare experiences.
// javacc can't deal comments that can optionally be directives, yet, or
// I haven't figured out how to yet.
|	< #LETTER :
		["A"-"Z"]|["a"-"z"]|"?"|"!"|":"|";"|"."|","|"‘"|"’"|"%"|"`"
		|"_"|"-"|"'"|"+"|<LANGLE>|<RANGLE>|<LPAR>|<RPAR>|"~"|"*"|"^"|"\""
		|"“"|"”"|"―"|"—"|"|"|"\\"|"$"|"@"|"✘"|"✔"|<LSB>|<RSB>|"&"
		|["\u00a1"-"\u09fe"]
	>
|	< #DIGIT  : ["0"-"9"] >
|	< EOL     : ("\n"|"\r")+ >			{ debugPrint("EOL"); }
}


void parse() :
{
	Token tok; String content = "";
}
{
	(
		(
			content=tag() {
				Config cfg = Config.read(content);
				if ((cfg != null && cfg.getName().equals("binary_path"))) {
					debugPrint("Binary Path found: " + cfg.getAttr("path").stringValue());
					bpaths.add(Path.of(cfg.getAttr("path").stringValue()));
				}
			}
			| content=expandAll(new Vector<>())
			| <HASH> { handleDirectiveOrComment(); }
			| (tok=<SPACE>|tok=<EOL>) { content = tok.image; }
		) {
			if (out != null) {
				out.print(content);
			}
			content = "";
		}
	)* <EOF>
}

// TODO use Config class here
String tag() :
{
	Token tstart, tend, body;
	String macro, contents;
	StringBuilder sb = new StringBuilder();
}
{
	(
		(tstart=<STAG>) {
			sb.append(tstart.image);
		}
		(<EOL>)?
		{
			// TODO can check tag mismatch here
			while (token.kind != ETAG) {
				if (getToken(1).kind == LBR) {
					// nested macro call
					sb.append(expandAll(new Vector<String>()));
				} else if (token.kind == HASH) {
					// handleDirectiveOrComment(); // FIXME faulty
					token = getNextToken();
				} else if (getToken(1).kind == STAG) {
					// nested tag
					sb.append("\t" + tag());
					token = getNextToken();
				} else {
					sb.append(token.image);
					token = getNextToken();
				}
			}

			debugPrint(position(tstart) + "-" + position(token) +  " Tag found: " + colorify(tstart.image, tagColor));
			sb.append(token.image);
		}
	) { return sb.toString(); }
}

void textdomain() :
{
	Token tok;
}
{
	<TEXTDOMAIN> <SPACE> (tok=<STRING>) { debugPrint("Textdomain " + colorify(tok.image, tdColor)); }
}

void define() :
{
	Token name, arg;
	Token key, val;
	Token doc;
	StringBuilder sb = new StringBuilder();
	Definition def;
	String macro;
	var args = new Vector<String>();
	var defArgs = new HashMap<String, String>();
	Map.Entry<String, String> defArg;
}
{
	(
		<DEFINE> <SPACE>
		(name=<STRING>)
		(
			(<SPACE>)+ (arg=<STRING>) { args.add(arg.toString()); }
		)*
		(<EOL>)+
		(
			(<SPACE>|<EOL>)+ (defArg=defaultArg(args)) {
				defArgs.put(defArg.getKey(), defArg.getValue());
			}
			(<EOL>)*
		)*
	) {
		String[] content = parseBodyUntil(ENDDEF, args);
		def = new Definition(name.toString(), content[0], args, defArgs);
		def.setDocs(content[1]);
		debugPrint("defining macro " + colorify(def.name(), macroNameColor));
		defines.addRow(name.beginLine-1, currentPath.toUri().toString(), name.image, def);
	}
}

Map.Entry<String, String> defaultArg(Vector<String> args) :
{
	Token argName, argBody;
}
{
	<ARG> <SPACE> argName=<STRING>
	(<SPACE>|<EOL>)+ {
		var sb = new StringBuffer();
		while (token.kind != ENDARG) {
			if (getToken(1).kind == LBR) {
				// nested macro call
				sb.append(expandAll(args));
			} else if (token.kind == HASH) {
				// handleDirectiveOrComment(); // FIXME faulty
				token = getNextToken();
			} else {
				// anything else is just appended as string to result
				sb.append(token.image);
				token = getNextToken();
			}
		}
		if (sb.toString().startsWith("\n")) {
			sb.deleteCharAt(0);
		}
		return Map.entry(argName.image, sb.toString());
	}
}

String expandAll(Vector<String> possibleArgs) :
{ String content = ""; }
{
	(
		expandPath()
		| content=expand(possibleArgs)
	) {
		return content;
	}
}

String expand(Vector<String> possibleArgs) :
{
	Token name, arg, defarg = null;
	String val;
	var defArgs = new HashMap<String, String>();
	Vector<String> args = new Vector<>();
	StringBuilder sb = new StringBuilder();
}
{
	(
		(<LBR>) (<SPACE>)* (name=<STRING>) { sb.append("{" + name.image); }
		(
			(<SPACE>|<EOL>)+
			(defarg=<STRING> <EQL>)?
			(
				val=expandAll(possibleArgs)
			|	(arg=<STRING>|arg=<PATH>|arg=<QUOTED_STRING>) { val = arg.image; }
			|	(arg=<INBLK>) {
					val = arg.image.substring(1, arg.image.length()-1);
				} // fix for parens
			) {
				sb.append(" " + val);
				if (defarg == null) {
					args.add(val);
				} else {
					defArgs.put(defarg.image, val);
				}
			}
		)*
		(<SPACE>|<EOL>)*
		(<RBR>) { sb.append("}"); }
	) {
		List<Table.Row> rows = defines.getRows("Name", name.image);
		Definition def = null;
		if (!rows.isEmpty()) {
			def = (Definition) rows.get(0).getColumn("Definition").getValue();
		}
		
		if (def != null) {
			String argsString = Definition.argsAsString(args, defArgs);
			debugPrint("expanding macro " + def.name()
				+ (!argsString.isEmpty() ? " with " + argsString : ""));
			try {
				String res = def.expand(args, defArgs);
				return res;
			} catch(IllegalArgumentException e) {
				errorPrint(e.getMessage());
				return sb.toString();
			}
		} else if (possibleArgs.contains(name.image)) {
			// FIXME: do nothing for now. may need checks later why this is happening.
			return sb.toString();
		} else {
			warningPrint(position(name) + " undefined macro " + name.image);
			return sb.toString();
		}
	}
}
void expandPath() :
{
	Token tok;
	StringBuilder sb = new StringBuilder();
}
{
	(<LBR> (<SPACE>)* (tok=<PATH>) (<SPACE>)* <RBR>) {
		Path p = FS.resolve(tok.image, bpaths, currentPath, token_source.dataPath, token_source.userDataPath);

		debugPrint("Trying to include: " + colorify(p.toString(), filePathColor));

		if (!Files.isDirectory(p) && !p.toString().endsWith(".cfg")) return;

		if (Files.exists(p)) {
			debugPrint("Including: " + colorify(p.toString(), filePathColor));
			try {
				subparse(p);
			} catch(IOException ioe) {
				errorPrint("Cannot find file/folder " + tok.image);
			}
		} else {
			warningPrint(tok.image + " not found");
		}
	}
}

void ifdef() :
{
	Token name;
}
{
	(<IFDEF> <SPACE> (name=<STRING>) <EOL>) {
		List<Table.Row> rows = defines.getRows("Name", name.image);
		Definition def = null;
		if (rows.isEmpty()) {
			debugPrint("ifdef: define " + name.image + " not found, skipping block");
			while (token.kind != ENDIF) {
				token = getNextToken();
			}
		} else {
			debugPrint("ifdef: define " + name.image + " found, parsing block");
		}
	}
}

void undef() :
{
	Token name;
}
{
	<UNDEF> <SPACE> (name=<STRING>) {
// TODO respect scope in LSP
//		debugPrint("removing macro " + name.toString());
//		defines.removeAll("Name", name.image);
	}

}


